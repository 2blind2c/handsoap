<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    ></title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><style type="text/css"
    >
ol.decimal { list-style-type: decimal; }
</style
    ></head
  ><body
  ><h1 id="handsoap"
    >Handsoap</h1
    ><h2 id="what"
    >What</h2
    ><p
    >Handsoap is a library for creating SOAP clients in Ruby.</p
    ><h2 id="why"
    >Why</h2
    ><p
    >Ruby already has a SOAP-client library, <a href="http://dev.ctor.org/soap4r"
      >soap4r</a
      >, so why create another one?</p
    ><blockquote
    ><p
      >Let me summarize SOAP4R: it smells like Java code built on a Monday morning by an EJB coder.</p
      ><p
      >-- <a href="http://blog.labnotes.org/2008/01/28/ruby-in-practice-rest-soap-websphere-mq-and-salesforce/"
	>Ruby In Practice: REST, SOAP, WebSphere MQ and SalesForce</a
	></p
      ></blockquote
    ><p
    >OK, not entirely fair, but soap4r has problems. It's incomplete and buggy. If you try to use it for any real-world services, you quickly run into compatibility issues. You can get around some of them, if you have control over the service, but you may not always be that lucky. In the end, even if you get it working, it has a bulky un-Rubyish feel to it.</p
    ><p
    >Handsoap tries to do better by taking a minimalistic approach. Instead of a full abstraction layer, it is more like a toolbox with which you can write SOAP bindings. You could think of it as a <a href="http://c2.com/cgi/wiki?ForeignFunctionInterface"
      >ffi</a
      > targeting SOAP.</p
    ><p
    >This means that you generally need to do more manual labor in the cases where soap4r would have automated the mapping. It also means that you need to get your hands dirty with wsdl, xsd and other heavyweight specifications. However, it does give you some tools to help you stay sane.</p
    ><p
    >There are several benefits of using Handsoap:</p
    ><ul
    ><li
      >It supports the entire SOAP specification, all versions (because you have to implement it your self).</li
      ><li
      >You actually get a sporting chance to debug and fix protocol level bugs.</li
      ><li
      >It's much faster than soap4r, because it uses fast low-level libraries for xml-parsing and http-communication.</li
      ></ul
    ><p
    >To summarise, soap4r takes an optimistic approach, where Handsoap expects things to fail. If soap4r works for you today, it's probably the better choice. If you find your self strugling with it, Handsoap will offer a more smooth ride. It won't magically fix things for you though.</p
    ><h2 id="soap-basics"
    >SOAP basics</h2
    ><p
    >SOAP is a protocol that is tunneled through XML over HTTP. Apart from using the technology for transportation, it doesn't have much to do with HTTP. Some times, it hasn't even got much to do with XML either.</p
    ><p
    >A SOAP client basically consists of three parts:</p
    ><ul
    ><li
      >A http-connectivity layer,</li
      ><li
      >a mechanism for marshalling native data types to XML,</li
      ><li
      >and a mechanism for unmarshalling XML to native data types.</li
      ></ul
    ><p
    >The protocol also contains a large and unwieldy specification of how to do the (un)marshalling, which can be used as the basis for automatically mapping to a rich type model. This makes the protocol fitting for .net/Java, but is a huge overhead for a very dynamically typed language such as Ruby. Much of the complexity of clients such as soap4r, is in the parts that tries to use this specification. Handsoap expects you to manually write the code that marshals/unmarshals, thereby bypassing this complexity (or rather - pass it to the programmer)</p
    ><p
    >Handsoap only supports RPC-style SOAP. This seems to be the most common style. It's probably possible to add support for Document-style with little effort, but until I see the need I'm not going there.</p
    ><h2 id="the-toolbox"
    >The toolbox</h2
    ><p
    >The Handsoap toolbox consists of the following components.</p
    ><p
    >Handsoap can use either <a href="http://curb.rubyforge.org/"
      >curb</a
      > or <a href="http://dev.ctor.org/http-access2"
      >httpclient</a
      > for HTTP-connectivity. The former is recommended, and default, but for portability you might choose the latter. You usually don't need to interact at the HTTP-level, but if you do (for example, if you have to use SSL), you can.</p
    ><p
    >For parsing XML, Handsoap uses <a href="http://github.com/tenderlove/nokogiri/tree/master"
      >Nokogiri</a
      >. While this may become optional in the future, the dependency is a bit tighter. The XML-parser is used internally in Handsoap, as well as by the code that maps from SOAP to Ruby (The code you're writing). Nokogiri is very fast (being based om libxml) and has a polished and stable api.</p
    ><p
    >There is also a library for generating XML, which you'll use when mapping from Ruby to SOAP. It's quite similar to <a href="http://builder.rubyforge.org/"
      >Builder</a
      >, but is tailored towards being used for writing SOAP-messages. The name of this library is <code
      >XmlMason</code
      > and it is included/part of Handsoap.</p
    ><h2 id="recommendations"
    >Recommendations</h2
    ><h3 id="workflow"
    >Workflow</h3
    ><ol class="decimal"
    ><li
      ><p
	>Find the wsdl for the service you want to consume.</p
	></li
      ><li
      ><p
	>Figure out the url for the endpoint, as well as the protocol version. (Look inside the wsdl)</p
	></li
      ><li
      ><p
	>Create a service class. Add endpoints and protocol. Import needed namespace(s).</p
	></li
      ><li
      ><p
	>Open the wsdl in <a href="http://www.soapui.org/"
	  >soapUI</a
	  >.</p
	></li
      ><li
      ><p
	>In soapUI, find a sample request for the method you want to use. Copy+paste the body-part.</p
	></li
      ><li
      ><p
	>Create a method in your service class (Use ruby naming convention)</p
	></li
      ><li
      ><p
	>Write Ruby-code (using XmlMason) to generate a request that is similar to the example from soapUI. (In your copy+paste buffer)</p
	></li
      ><li
      ><p
	>Write Ruby-code to parse the response (a Nokogiri XML-document) into Ruby data types.</p
	></li
      ><li
      ><p
	>Write an integration test to verify that your method works as expected. You can use soapUI to generate a mock-service.</p
	></li
      ></ol
    ><p
    >Repeat point 5..9 for each method that you need to use. Between each iteration, you should refactor shared code into helper functions.</p
    ><h3 id="service-class"
    >Service class</h3
    ><p
    >Put your service in a file under <code
      >app/models</code
      >. You should extend <code
      >Handsoap::Service</code
      >.</p
    ><p
    >You need to provide the endpoint and the SOAP version (1.1 or 1.2). If in doubt, use version 2.</p
    ><p
    >A service usually has a namespace for describing the message-body (<a href="http://www.ibm.com/developerworks/webservices/library/ws-whichwsdl/#N1011F"
      >RPC/Litteral style</a
      >). You should set this in the <code
      >on_create_document</code
      > handler.</p
    ><p
    >A typical service looks like the following:</p
    ><pre
    ><code
      ># -*- coding: utf-8 -*-
require 'handsoap'

class Example::FooService &lt; Handsoap::Service
  endpoint :uri =&gt; 'http://example.org/ws/service', :version =&gt; 2
  on_create_document do |doc|
    doc.alias 'wsdl', &quot;http://example.org/ws/spec&quot;
  end
  # public methods
  # todo

  private
  # helpers
  # todo
end
</code
      ></pre
    ><p
    >The above would go in the file <code
      >app/models/example/foo_service.rb</code
      ></p
    ><h3 id="integration-tests"
    >Integration tests</h3
    ><p
    >Since you're writing mappings manually, it's a good idea to write tests that verify that the service works. If you use standard Rails with <code
      >Test::Unit</code
      >, you should put these in an integration-test.</p
    ><p
    >For the sample service above, you would create a file in <code
      >test/integration/example/foo_service.rb</code
      >, with the following content:</p
    ><pre
    ><code
      ># -*- coding: utf-8 -*-
require 'test_helper'

# Example::FooService.logger = $stdout

class Example::FooServiceTest &lt; Test::Unit::TestCase
  def test_update_icon
    icon = { :href =&gt; 'http://www.example.com/icon.jpg', :type =&gt; 'image/jpeg' }
    result = Example::FooService.update_icon!(icon)
    assert_equal icon.type, result.type
  end
end
</code
      ></pre
    ><p
    >Note the commented-out line. If you set a logger on the service-class, you can see the protocol-level interaction, which is useful for debugging.</p
    ><h3 id="methods"
    >Methods</h3
    ><p
    >You should use Ruby naming-conventions for methods names. If the method has side-effects, you should postfix it with an exclamation. Repeat code inside the invoke-block, should be refactored out to <em
      >builders</em
      >, and the response should be parsed with a <em
      >parser</em
      >.</p
    ><pre
    ><code
      >def update_icon!(icon)
  response = invoke(&quot;wsdl:UpdateIcon&quot;) do |message|
    build_icon!(message, icon)
  end
  parse_icon(response.document.xpath('//icon').first)
end
</code
      ></pre
    ><h3 id="helpers"
    >Helpers</h3
    ><p
    >You'll end up with two kinds of helpers; Ruby-&gt;XML transformers (aka. <em
      >builders</em
      >) and XML-&gt;Ruby transformers (aka. <em
      >parsers</em
      >). It's recommended that you stick to the following style/naming scheme:</p
    ><pre
    ><code
      ># icon -&gt; xml
def build_icon!(message, icon)
  message.add &quot;icon&quot; do |i|
    i.set_attr &quot;href&quot;, icon[:href]
    i.set_attr &quot;type&quot;, icon[:type]
  end
end

# xml -&gt; icon
def parse_icon(node)
  { :href =&gt; node['href'], :type =&gt; node['type'] }
end
</code
      ></pre
    ><p
    >or, if you prefer, you can use a class to represent entities:</p
    ><pre
    ><code
      ># icon -&gt; xml
def build_icon!(message, icon)
  message.add &quot;icon&quot; do |i|
    i.set_attr &quot;href&quot;, icon.href
    i.set_attr &quot;type&quot;, icon.type
  end
end

# xml -&gt; icon
def parse_icon(node)
  Icon.new :href =&gt; node['href'],
           :type =&gt; node['type']
end
</code
      ></pre
    ><h2 id="license"
    >License</h2
    ><p
    >Copyright: <a href="http://www.unwire.dk"
      >Unwire A/S</a
      >, 2009</p
    ><p
    >License: ???</p
    ><hr
     /><p
    >troelskn@gmail.com - April, 2009</p
    ></body
  ></html
>

